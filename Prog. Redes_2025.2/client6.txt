import socket
import struct
import sys
import os
import time

# --- Configura√ß√µes de Conex√£o ---
HOST = '127.0.0.1'
PORT = 50000
DOWNLOAD_DIR = 'downloads/'
TIMEOUT = 5.0 # Timeout para esperar a resposta
BUFFER_SIZE = 4096 # Tamanho m√°ximo do datagrama (incluindo cabe√ßalho de 1 byte no protocolo)

print("--- Cliente UDP de Arquivos ---")

# 1. Obter o nome do arquivo de forma interativa
# Removida a depend√™ncia de sys.argv para evitar o SystemExit no ambiente de execu√ß√£o.
filename = input("Digite o nome do arquivo a solicitar: ")

if not filename:
    print("Nome do arquivo n√£o pode estar vazio. Encerrando.")
    sys.exit(1)

# 2. PREPARA O DATAGRAMA DE SOLICITA√á√ÉO
# O cliente usa um protocolo simples: [1 byte: Tamanho do nome] [Nome do Arquivo]
filename_bytes = filename.encode('utf-8')
filename_size = len(filename_bytes) 

if filename_size > 255:
    print("O nome do arquivo √© muito longo.")
    sys.exit(1)

# Empacota o tamanho do nome do arquivo (como um √∫nico byte n√£o assinado)
size_byte_to_send = struct.pack('>B', filename_size) 
request_datagram = size_byte_to_send + filename_bytes

try:
    # 3. Configura√ß√£o e Envio
    client_socket = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
    client_socket.settimeout(TIMEOUT) # Define um timeout para as opera√ß√µes de recebimento
    
    # Envia a solicita√ß√£o
    client_socket.sendto(request_datagram, (HOST, PORT))
    print(f"[*] Solicitado arquivo: **{filename}**")

    # 4. RECEBE A CONFIRMA√á√ÉO DO SERVIDOR
    # O servidor responde com: [1 byte status] [8 bytes tamanho do arquivo Q]
    data, addr = client_socket.recvfrom(BUFFER_SIZE)
    
    status = data[:1].decode('utf-8')

    if status == '0': # C√≥digo '0' = Arquivo Encontrado
        print("[+] Servidor confirmou: Arquivo encontrado. Recebendo...")

        # O restante dos 8 bytes cont√©m o tamanho total do arquivo
        if len(data) < 9:
             print("[-] Erro: Resposta de confirma√ß√£o incompleta do servidor.")
             sys.exit(1)
             
        size_file_bytes = data[1:9]
        # 'Q' √© o formato para um unsigned long long (8 bytes), que representa o tamanho do arquivo
        file_size = struct.unpack('>Q', size_file_bytes)[0]
        print(f"[*] Tamanho total do arquivo a receber: {file_size} bytes")

        # 5. RECEBE O CONTE√öDO (em m√∫ltiplos datagramas)
        bytes_received = 0
        file_data = b''
        
        # Aumentamos o tempo limite geral para acomodar transfer√™ncias grandes
        # O cliente tentar√° receber dados por um per√≠odo de tempo total.
        MAX_TRANSFER_TIME = 30.0 # 30 segundos no total
        end_time = time.time() + MAX_TRANSFER_TIME
        
        print(f"[*] Iniciando recebimento. Tempo limite total de {MAX_TRANSFER_TIME} segundos.")

        # Loop principal de recebimento
        while bytes_received < file_size and time.time() < end_time:
            # Redefine o timeout do socket a cada itera√ß√£o para o timeout inicial (5.0s),
            # garantindo que cada recvfrom n√£o espere para sempre.
            client_socket.settimeout(TIMEOUT) 
            
            try:
                # O servidor envia chunks com tamanho m√°ximo de BUFFER_SIZE
                chunk, addr = client_socket.recvfrom(BUFFER_SIZE)
                
                # Para evitar loops infinitos ou lixo no final, verificamos se o dado √© v√°lido
                if not chunk:
                    break
                    
                file_data += chunk
                bytes_received += len(chunk)
                
                # Feedback simples
                sys.stdout.write(f"\rRecebido: {bytes_received} / {file_size} bytes ({bytes_received/file_size*100:.2f}%)")
                sys.stdout.flush()

            except socket.timeout:
                print("\n[-] Timeout na espera do pr√≥ximo peda√ßo.")
                break
        
        print("\n[*] Fim do loop de recebimento.")
        
        # 6. SALVA O ARQUIVO (Verificamos a integridade)
        if bytes_received == file_size:
            print("[+] Sucesso: Todos os bytes foram recebidos.")
            
            os.makedirs(DOWNLOAD_DIR, exist_ok=True)
            download_path = os.path.join(DOWNLOAD_DIR, filename)
            
            with open(download_path, 'wb') as f:
                f.write(file_data) 
            
            print(f"üéâ Arquivo salvo com sucesso em: **{download_path}**")

        elif bytes_received > file_size:
            # Trunca se houver lixo a mais (ocorre raramente em UDP)
            print(f"‚ö†Ô∏è AVISO: Recebido mais bytes ({bytes_received}) do que o esperado ({file_size}). Truncando.")
            os.makedirs(DOWNLOAD_DIR, exist_ok=True)
            download_path = os.path.join(DOWNLOAD_DIR, filename)
            with open(download_path, 'wb') as f:
                f.write(file_data[:file_size]) 
            print(f"üéâ Arquivo salvo (truncado) em: **{download_path}**")

        else:
            loss_percent = (1 - (bytes_received / file_size)) * 100
            print(f"\n[-] Erro: Recebido apenas {bytes_received} de {file_size} bytes. Perda de {loss_percent:.2f}%. Falha na transfer√™ncia UDP.")

    elif status == '1': # C√≥digo '1' = Arquivo N√£o Encontrado
        print(f"‚ùå Servidor informou: Arquivo '{filename}' n√£o encontrado.")
        
    else:
        print(f"[-] Resposta de status desconhecida do servidor: {data}")

except socket.timeout:
    print("[-] Timeout: Nenhuma resposta inicial recebida do servidor.")
except Exception as e:
    print(f"[-] Ocorreu um erro: {e}")
finally:
    if 'client_socket' in locals() and client_socket:
        client_socket.close()
        print("[*] Socket do cliente fechado.")